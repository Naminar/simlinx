- instruction: lui
  decode: |
    decodedInstr.imm = IMM20;
    decodedInstr.rd = RD;
  jit: |
    auto imm = sext<20>(IMM20);
    auto rd  = jit.reg_64(RD);
    jit.gen.mov(rd, imm);
    jit.gen.shl(rd, 12);
  execute: |
    core.regs[rd] = sext<20>(imm) << 12;


- instruction: auipc
  decode: |
    decodedInstr.imm = IMM20;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.pc_reg + (sext<20>(imm) << 12);


- instruction: jal
  decode: |
    decodedInstr.rd = RD;
    decodedInstr.imm = bitsFrom(decodedBits,  31,  31) << 20
                          | bitsFrom(decodedBits, 19, 12) << 12
                          | bitsFrom(decodedBits, 20, 20) << 11
                          | bitsFrom(decodedBits, 30, 21) << 1;
  execute: |
    core.regs[rd] = core.pc_reg + 4;
    core.pc_reg += sext<21>(imm);


- instruction: jalr
  decode: |
    decodedInstr.rd = RD;
    decodedInstr.rs1 = RS1;
    decodedInstr.imm = IMM12;
  jit: |
    jit.gen.ret();
  execute: |
    reg_t tmp = core.pc_reg + 4;
    core.pc_reg = (core.regs[rs1] + sext<12>(imm)) &  ~1U;
    core.regs[rd] = tmp;


- instruction: beq
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.imm = bitsFrom(decodedBits, 7, 7) << 11
                        | bitsFrom(decodedBits, 11, 8) << 1
                        | bitsFrom(decodedBits, 30, 25) << 5
                        | bitsFrom(decodedBits, 31, 31) << 12;
  execute: |
    core.pc_reg += (core.regs[rs1] == core.regs[rs2])? sext<13>(imm) : 4U;


- instruction: bne
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.imm = bitsFrom(decodedBits, 7, 7) << 11
                        | bitsFrom(decodedBits, 11, 8) << 1
                        | bitsFrom(decodedBits, 30, 25) << 5
                        | bitsFrom(decodedBits, 31, 31) << 12;
  execute: |
    core.pc_reg += (core.regs[rs1] != core.regs[rs2])? sext<13>(imm) : 4U;


- instruction: blt
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.imm = bitsFrom(decodedBits, 7, 7) << 11
                        | bitsFrom(decodedBits, 11, 8) << 1
                        | bitsFrom(decodedBits, 30, 25) << 5
                        | bitsFrom(decodedBits, 31, 31) << 12;
  execute: |
    core.pc_reg += (asSigned(core.regs[rs1]) < asSigned(core.regs[rs2]))? sext<13>(imm) : 4U;


- instruction: bge
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.imm = bitsFrom(decodedBits, 7, 7) << 11
                        | bitsFrom(decodedBits, 11, 8) << 1
                        | bitsFrom(decodedBits, 30, 25) << 5
                        | bitsFrom(decodedBits, 31, 31) << 12;
  jit: |
    jit.gen.ret();
  execute: |
    core.pc_reg += (asSigned(core.regs[rs1]) >= asSigned(core.regs[rs2]))? sext<13>(imm) : 4U;


- instruction: bltu
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.imm = bitsFrom(decodedBits, 7, 7) << 11
                        | bitsFrom(decodedBits, 11, 8) << 1
                        | bitsFrom(decodedBits, 30, 25) << 5
                        | bitsFrom(decodedBits, 31, 31) << 12;
  execute: |
    core.pc_reg += (core.regs[rs1] < core.regs[rs2])? sext<13>(imm) : 4U;


- instruction: bgeu
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.imm = bitsFrom(decodedBits, 7, 7) << 11
                        | bitsFrom(decodedBits, 11, 8) << 1
                        | bitsFrom(decodedBits, 30, 25) << 5
                        | bitsFrom(decodedBits, 31, 31) << 12;
  execute: |
    core.pc_reg += (core.regs[rs1] >= core.regs[rs2])? sext<13>(imm) : 4U;


- instruction: lb
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
    decodedInstr.imm = IMM12;
  execute: |
    core.regs[rd] = sext<8>(
                              bitsFrom(core.mem.load<uint64_t>(core.regs[rs1] + sext<12>(imm)), 7, 0)
                            );


- instruction: lh
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
    decodedInstr.imm = IMM12;
  execute: |
    core.regs[rd] = sext<16>(
                              bitsFrom(core.mem.load<uint64_t>(core.regs[rs1] + sext<12>(imm)), 15, 0)
                            );


- instruction: lw
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
    decodedInstr.imm = IMM12;
  jit: |
    auto rs1 = jit.reg_64(RS1);
    auto rd  = jit.reg_32(RD);
    auto imm = sext<12>(IMM12);
    jit.gen.mov(rd, ptr[rs1 + imm]);
    jit.gen.movsxd(rd.cvt64(), rd);
  execute: |
    core.regs[rd] = sext<32>(
                              bitsFrom(core.mem.load<uint64_t>(core.regs[rs1] + sext<12>(imm)), 31, 0)
                            );


- instruction: ld
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
    decodedInstr.imm = IMM12;
  jit: |
    auto rs1 = jit.reg_64(RS1);
    auto rd  = jit.reg_64(RD);
    auto imm = sext<12>(IMM12);
    jit.gen.mov(rd, ptr[rs1 + imm]);
  execute: |
    core.regs[rd] = core.mem.load<uint64_t>(core.regs[rs1] + sext<12>(imm));


- instruction: lbu
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
    decodedInstr.imm = IMM12;
  execute: |
    core.regs[rd] = bitsFrom(core.mem.load<uint64_t>(core.regs[rs1] + sext<12>(imm)), 7, 0);


- instruction: lhu
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
    decodedInstr.imm = IMM12;
  execute: |
    core.regs[rd] = bitsFrom(core.mem.load<uint64_t>(core.regs[rs1] + sext<12>(imm)), 15, 0);


- instruction: sb
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.imm = IMM12HI << 5 | IMM12LO;
  execute: |
    core.mem.store<uint8_t>(core.regs[rs1] + sext<12>(imm), bitsFrom(core.regs[rs2], 7, 0));


- instruction: sh
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.imm = IMM12HI << 5 | IMM12LO;
  execute: |
    core.mem.store<uint16_t>(core.regs[rs1] + sext<12>(imm), bitsFrom(core.regs[rs2], 15, 0));


- instruction: sw
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.imm = IMM12HI << 5 | IMM12LO;
  jit: |
    auto rs1 = jit.reg_64(RS1);
    auto rs2 = jit.reg_32(RS2);
    auto imm = sext<12>(IMM12HI << 5 | IMM12LO);
    jit.gen.mov(ptr[rs1 + imm], rs2);
  execute: |
    core.mem.store<uint32_t>(core.regs[rs1] + sext<12>(imm), bitsFrom(core.regs[rs2], 31, 0));


- instruction: sd
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.imm = IMM12HI << 5 | IMM12LO;
  jit: |
    auto rs1 = jit.reg_64(RS1);
    auto rs2 = jit.reg_64(RS2);
    auto imm = sext<12>(IMM12HI << 5 | IMM12LO);
    jit.gen.mov(ptr[rs1 + imm], rs2);
  execute: |
    core.mem.store<uint64_t>(core.regs[rs1] + sext<12>(imm), bitsFrom(core.regs[rs2], 63, 0));


- instruction: addi
  decode: |
    decodedInstr.imm = IMM12;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  jit: |
    auto imm = sext<12>(IMM12);
    auto rs1 = jit.reg_64(RS1);
    auto rd  = jit.reg_64(RD);        
    auto tmp = jit.tmp_64;
    jit.gen.lea(rd, ptr[rs1 + imm]);
  execute: |
    core.regs[rd] = core.regs[rs1] + sext<12>(imm);


- instruction: slti
  decode: |
    decodedInstr.imm = IMM12;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = asSigned(core.regs[rs1]) < asSigned(sext<12>(imm));

- instruction: sltiu
  decode: |
    decodedInstr.imm = IMM12;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] < sext<12>(imm);


- instruction: xori
  decode: |
    decodedInstr.imm = IMM12;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] ^ sext<12>(imm);


- instruction: ori
  decode: |
    decodedInstr.imm = IMM12;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] | sext<12>(imm);

- instruction: andi
  decode: |
    decodedInstr.imm = IMM12;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] & sext<12>(imm);


- instruction: add
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] + core.regs[rs2];


- instruction: sub
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] - core.regs[rs2];


- instruction: sll
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] << core.regs[rs2];


- instruction: slt
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = asSigned(core.regs[rs1]) < asSigned(core.regs[rs2]);


- instruction: sltu
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] < core.regs[rs2];


- instruction: xor
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] ^ core.regs[rs2];


- instruction: srl
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] >> core.regs[rs2];


- instruction: sra
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = asSigned(core.regs[rs1]) >> core.regs[rs2];


- instruction: or
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] | core.regs[rs2];


- instruction: and
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rs2 = RS2;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] & core.regs[rs2];


- instruction: fence
  decode: |
  execute: |


- instruction: ecall
  decode: |
  execute: |
    core.fault = ::Syscall::syscalls[core.regs[simlinx::Register::a7]](core);


- instruction: ebreak
  decode: |
  execute: |


- instruction: addiw
  decode: |
    decodedInstr.imm = IMM12;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  jit: |
    auto imm = sext<12>(IMM12);
    auto rs1 = jit.reg_64(RS1);
    auto rd  = jit.reg_32(RD);
    jit.gen.lea(rd, ptr[rs1 + imm]);
    jit.gen.movsxd(rd.cvt64(), rd);
  execute: |
    core.regs[rd] = sext<32>(bitsFrom(core.regs[rs1] + sext<12>(imm), 31, 0));


- instruction: addw
  decode: |
    decodedInstr.rs2 = RS2;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = sext<32>(bitsFrom(core.regs[rs1] + core.regs[rs2], 31, 0));


- instruction: slli
  decode: |
    decodedInstr.imm = IMM6; // RV64 mode
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] << imm;


- instruction: slliw
  decode: |
    decodedInstr.imm = IMM5;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = sext<32>(bitsFrom(core.regs[rs1] << imm, 31, 0));


- instruction: srli
  decode: |
    decodedInstr.imm = IMM5;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = core.regs[rs1] >> imm;


- instruction: srliw
  decode: |
    decodedInstr.imm = IMM5;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = sext<32>(bitsFrom(core.regs[rs1], 31, 0) >> imm);


- instruction: sraiw
  decode: |
    decodedInstr.imm = IMM5;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = sext<32>(asSigned<int32_t>(core.regs[rs1]) >> imm);


- instruction: subw
  decode: |
    decodedInstr.rs2 = RS2;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = sext<32>(bitsFrom(core.regs[rs1] - core.regs[rs2], 31, 0));


- instruction: sllw
  decode: |
    decodedInstr.rs2 = RS2;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = sext<32>(bitsFrom(core.regs[rs1] << bitsFrom(core.regs[rs2], 4, 0), 31, 0));


- instruction: srlw
  decode: |
    decodedInstr.rs2 = RS2;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = sext<32>(bitsFrom(core.regs[rs1], 31, 0) >> bitsFrom(core.regs[rs2], 4, 0));


- instruction: sraw
  decode: |
    decodedInstr.rs2 = RS2;
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
  execute: |
    core.regs[rd] = sext<32>(asSigned<int32_t>(core.regs[rs1]) >> bitsFrom(core.regs[rs2], 4, 0));


- instruction: lwu
  decode: |
    decodedInstr.rs1 = RS1;
    decodedInstr.rd = RD;
    decodedInstr.imm = IMM12;
  execute: |
    core.regs[rd] = core.mem.load<uint32_t>(core.regs[rs1] + sext<12>(imm));


- instruction: mret
  decode: ""
  execute: ""